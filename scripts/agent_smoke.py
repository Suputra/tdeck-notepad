#!/usr/bin/env python3
"""Run a deterministic write-and-capture smoke test for T-Deck debug firmware."""

from __future__ import annotations

import argparse
from datetime import datetime
from pathlib import Path
import re
import subprocess
import sys

try:
    import cv2
except ImportError as exc:  # pragma: no cover - import error path
    raise SystemExit("opencv-python is required. Run: uv sync") from exc


STATE_RE = re.compile(r"AGENT OK STATE .*text_len=(\d+)")
DEFAULT_CAMERA_SOURCE = "http://10.0.44.199:4747/"


def run_command(cmd: list[str]) -> str:
    res = subprocess.run(cmd, capture_output=True, text=True)
    if res.stdout:
        print(res.stdout, end="")
    if res.stderr:
        print(res.stderr, end="", file=sys.stderr)
    if res.returncode != 0:
        raise RuntimeError(f"command failed: {' '.join(cmd)}")
    return (res.stdout or "") + (res.stderr or "")


def analyze_image(path: Path) -> tuple[float, float, float]:
    img = cv2.imread(str(path), cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise RuntimeError(f"failed to read image: {path}")
    mean = float(img.mean())
    std = float(img.std())
    dark_pct = float((img < 10).mean() * 100.0)
    return mean, std, dark_pct


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Write marker text to T-Deck notepad, capture a frame, and run basic checks."
    )
    parser.add_argument("--port", help="Serial port for T-Deck device (optional auto-detect)")
    parser.add_argument(
        "--camera-source",
        default=DEFAULT_CAMERA_SOURCE,
        help="Camera source URL or device index string",
    )
    parser.add_argument(
        "--camera-device",
        type=int,
        help="Deprecated webcam device index; overrides --camera-source",
    )
    parser.add_argument("--warmup", type=float, default=2.0, help="Camera warmup seconds")
    parser.add_argument("--wait-ms", type=int, default=1800, help="Wait after render before capture")
    parser.add_argument("--boot-wait", type=float, default=0.0, help="Seconds to read boot logs first")
    parser.add_argument("--marker", help="Text marker to write on notepad")
    parser.add_argument("--image", help="Output image path")
    args = parser.parse_args()

    if args.marker:
        marker = args.marker
    else:
        # Keep autogenerated markers keypad-safe (letters + '-').
        digits = datetime.now().strftime("%H%M%S")
        letters = "".join(chr(ord("a") + int(d)) for d in digits)
        marker = f"smoke-{letters}"

    if "0" in marker:
        print("[smoke] FAIL: marker contains '0', which is not supported by TEXT typing path.")
        print("[smoke] Use a marker without '0' or pass custom keypad-safe text via --marker.")
        return 6
    expected_len = len(marker)
    camera_source = str(args.camera_device) if args.camera_device is not None else args.camera_source

    artifacts = Path("artifacts")
    artifacts.mkdir(parents=True, exist_ok=True)
    image_path = Path(args.image) if args.image else artifacts / f"{marker}.jpg"

    tdeck_cmd = [sys.executable, "scripts/tdeck_agent.py"]
    if args.port:
        tdeck_cmd += ["--port", args.port]
    if args.boot_wait > 0:
        tdeck_cmd += ["--boot-wait", str(args.boot_wait)]
    tdeck_cmd += [
        "CMD rm __agent_smoke__.txt",
        "CMD edit __agent_smoke__.txt",
        f"TEXT {marker}",
        "RENDER",
        f"WAIT {args.wait_ms}",
        "STATE",
    ]

    print(f"[smoke] marker={marker}")
    out = run_command(tdeck_cmd)
    if "AGENT ERR" in out:
        print("[smoke] FAIL: AGENT ERR observed in serial output", file=sys.stderr)
        return 2

    state_matches = STATE_RE.findall(out)
    if not state_matches:
        print("[smoke] FAIL: no AGENT OK STATE line found", file=sys.stderr)
        return 3
    text_len = int(state_matches[-1])
    if text_len != expected_len:
        print(
            f"[smoke] FAIL: text_len mismatch expected={expected_len} actual={text_len}",
            file=sys.stderr,
        )
        return 4

    cap_cmd = [
        sys.executable,
        "scripts/capture_webcam.py",
        "--source",
        camera_source,
        "--warmup",
        str(args.warmup),
        "--image",
        str(image_path),
    ]
    run_command(cap_cmd)

    mean, std, dark_pct = analyze_image(image_path)
    if mean <= 5.0 or std <= 2.0:
        print(
            f"[smoke] FAIL: capture looks invalid mean={mean:.2f} std={std:.2f}",
            file=sys.stderr,
        )
        return 5

    print("[smoke] PASS")
    print(f"[smoke] image={image_path}")
    print(f"[smoke] serial_text_len={text_len}")
    print(f"[smoke] image_mean={mean:.2f} image_std={std:.2f} image_dark_pct={dark_pct:.2f}")
    print("[smoke] NOTE: confirm marker visibility in the image for full visual verification.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
